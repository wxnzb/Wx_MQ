## 1
```
func (p *Partition) Pub(cl *Client) {
	//要是客户端活着，先得到消息
	for {
		cl.rmu.RLock()
		//cl.state=="alive写成这样可以吗
		if cl.state == ALIVE {
			name := cl.name
			cl.rmu.RUnlock()
			p.rmu.RLock()
			offset := p.consumer_offset[name]
			msg := p.queue[offset]
			p.rmu.Unlock()
			ret := cl.Pub(msg)
			if ret {
				p.rmu.Lock()
				p.consumer_offset[name]=offset+1
				p.rmu.Unlock()
			}
		} else {
			cl.rmu.Unlock()
			time.Sleep(5 * time.Second)
		}
	}

}
```
- p.consumer_offset[name]=offset+1之前好奇为什么这个代码不能写成p.consumer_offset[name]++,go语言根本就没有这种语法
## 2
-  点对点订阅
-  1.多个消费者订阅同一个 topic；2.但每条消息 只会被其中一个人处理；3.一种 轮流消费 的模式一个topic下面有有多个消费者，eg:现在topic相当是一个公司，然后消费者相当于快递员，要是现在来了个快递，他们就要抢着做，任务只会分配给一个员工
-  按key的发布订阅
-  1.每个消息有一个 key（比如用户 ID、订单号）；2.每个消费者订阅了一个 key；3.只要消息 key 匹配这个消费者的 key，就发给他。在上面的基础上，现在每个员工就对应一个key,比如A快递员对应上海，那么发向上海的快递都交给他
-  我感觉就是第一种就是一个topic里面就一个队列
-  第二种就是一个topic对应多个分区
## 3
```
//按key发布的订阅
	case TOPIC_KEY_PSB:{
		group:=NewGroup(req.topic,req.consumer)
		sub.groups=append(sub.groups,group)
		sub.consumer_partition[req.consumer]=req.key
	}
```
- 详细解释一下这段代码，尤其是左后一行
- 首先他是他通过req *api.SubRequest，知道是在哪个topic,找到后在*Topic中通过SubList map[string]*SubScription这里key就是topic_name+option，现在是处理找到的情况里面通过option判断出这个客户是想用key的方式订阅，所以他就为这个消费者绑定了key
- eg:
- 假设你现在在做快递系统，有下面这些设定：
- 「城市快递」
- 你有三个快递员（消费者）：小明、小红、小刚
- 每个快递员只负责一个城市：
- 小明：负责上海（key = "shanghai"）
- 小红：负责北京（key = "beijing"）
- 小刚：负责广州（key = "guangzhou"）
- 于是你用这句代码：
```
sub.consumer_partition["小明"] = "shanghai"
sub.consumer_partition["小红"] = "beijing"
sub.consumer_partition["小刚"] = "guangzhou"
```
- 当一个消费者（比如“小红”）订阅了 topic，并传了 key=“beijing”，就会执行：
```
group := NewGroup("城市快递", "小红")
sub.groups = append(sub.groups, group)
sub.consumer_partition["小红"] = "beijing"
```
- 系统就记录：小红负责 beijing
- 发布阶段：
当生产者发出一条消息，key=“beijing”，系统会：
```
for consumer, key := range sub.consumer_partition {
    if key == "beijing" {
        // 找到了！这条消息应该发给这个消费者（小红）
    }
}
```