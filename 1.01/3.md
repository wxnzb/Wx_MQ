## 1
- 在.thrift生成的kitex_gen/api文件中
- client_operations和server_operations他们名字像是一个处理客户端一个处理服务端，但是不是，他们其实十分长类似的，只是client_operations处理的是pingpong这种简单控制类接口请求，server_operations处理的是push,pull,info这种真正的业务逻辑接口请求
## 2
- fmt.Println(err) 和 println(err.Error()) 区别
- fmt.Println(err) 比 println(err.Error()) 更安全、更规范、更灵活，
所以正式代码里，尽量用 fmt.Println
## 3
- Info(ctx context.Context, req *api.InfoRequest, callOptions ...callopt.Option) (r *api.InfoResponse, err error)他这里ctx context.Context现在看着感觉没什么用，单数为了以后拓展打下基础
- eg:
```
ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
defer cancel()

srv.Push(ctx, req)
```
- 假设一个请求要5秒才能完成，用户1秒后就点了“取消”。如果没有 context，服务器还傻傻继续跑5秒，非常浪费资源！如果有 context，你可以随时监听 ctx.Done()，一旦用户取消，就立刻中断处理，节省 CPU、内存、网络资源
## 4
- 在理解client/client.go的时候,不理解端口设置与连接
- 代码如下
```
    //pub and pingpong
	go start_server(":8889")
	//push pull info
	client, err := server_operations.NewClient("client", cl.WithHostPorts("0.0.0.0:8888"))
```
- 第一个是创建了一个自己的小服务器，负责接收来自其他客户端的请求，并处理发布消息或 ping-pong 的操作
- 表示客户端连接到一个运行在 8888 端口上的服务器，这通常是一个 Broker 服务的端口，负责处理消息的推送（Push）、拉取（Pull）等操作
- 那整个流程就是这样，8889端口首先是一个服务器，他负责监听客户端的连接，与客户端进行pingpong操作和pub操作，pub操作会得到某个客户端发来的消息，然后8889这个端口又作为客户端连接的broker，它可以和broker进行push,pull,info这一系列操作将消息传给broker，所以8889这个端口有点像中转站的样子
## 5
```
    //这个是为了反向代理，当broker有消息要发给这个中转站的时候就能找到了
	resp, err := client.Info(context.Background(), info)
```
- 我好奇那为什么不在client, err := server_operations.NewClient("client", cl.WithHostPorts("0.0.0.0:8888"))刚开始连接的时候就将他的地址存起来
- 这一步他只是打通了，可以TCP连接了，上面那个才是真正存起来。eg:打电话连接上客服中心（建立连接了）但客服不会一接通就知道你是谁，你要干嘛，对吧？所以你得报名字、说要办什么业务。（InfoRequest）
